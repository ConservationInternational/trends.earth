"""Classes for interfacing UI with report models."""
import typing

from qgis.PyQt.QtCore import (
    QAbstractItemModel,
    QCoreApplication,
    QModelIndex,
    Qt
)
from qgis.PyQt.QtGui import (
    QStandardItem,
    QStandardItemModel
)
from qgis.PyQt.QtWidgets import (
    QComboBox,
    QMenu,
    QPushButton,
    QStyledItemDelegate,
    QStyleOptionViewItem,
    QWidget
)

from te_schemas.jobs import JobStatus

from ..jobs.models import Job
from ..logger import log
from .models import (
    ReportConfiguration,
    ItemScopeMapping,
    ReportTaskContext
)

from .generator import report_generator
from .template_manager import template_manager
from .utils import (
    job_has_report,
    job_has_results
)
from ..utils import FileUtils


class DatasetReportHandler:
    """
    Interface for functionality related to report generation and viewing
    as well as template editing for each dataset generated by the
    algorithms.
    """
    def __init__(self, rpt_btn: QPushButton, job: Job) -> None:
        self._rpt_btn = rpt_btn
        self._job = job
        self._rpt_menu = QMenu()
        self._view_rpt_action = None
        self._open_template_action = None
        self._rpt_config = None
        self._rpt_task_ctx = None
        self._regenerate_report = False

    @property
    def report_button(self) -> QPushButton:
        return self._rpt_btn

    @property
    def job(self) -> Job:
        return self._job

    @property
    def report_menu(self) -> QMenu:
        return self._rpt_menu

    def init(self) -> None:
        """Creates sub-menus and set state based on job status."""
        self._view_rpt_action = self._rpt_menu.addAction(
            FileUtils.get_icon('view.svg'),
            'View report'
        )
        self._view_rpt_action.triggered.connect(self.view_report)

        self._open_template_action = self._rpt_menu.addAction(
            FileUtils.get_icon('layout.svg'),
            'Open template'
        )
        self._open_template_action.triggered.connect(self.open_designer)

        self._rpt_btn.setMenu(self._rpt_menu)

        # Check report configuration
        scope = self._job.script.name
        single_scope_configs = template_manager.single_scope_configs()
        configs = template_manager.configs_by_scope_name(
            scope,
            single_scope_configs
        )

        if len(configs) == 0:
            self._rpt_btn.setVisible(False)
            return
        else:
            self._rpt_config = configs[0]

        # Check if qpt should be included in the output
        if self._rpt_config.output_options.include_qpt:
            self._open_template_action.setEnabled(True)
        else:
            self._open_template_action.setEnabled(False)

        # Enable/disable report button based on job and results status
        rpt_status = self._check_job_report_status()
        self._rpt_btn.setEnabled(rpt_status)

        # For previously finished jobs but there is no report, submit the
        # job for report generation.
        if self._regenerate_report and \
                not report_generator.is_task_running(self.report_task_id):
            self.generate_report()

    def _check_job_report_status(self) -> bool:
        # Check job status, assert datasets are available and no report has
        # been generated yet.
        if not self._job.status in (
                JobStatus.DOWNLOADED,
                JobStatus.GENERATED_LOCALLY
        ):
            return False

        if not job_has_results(self._job):
            return False

        else:
            if not job_has_report(
                    self._job,
                    self._rpt_config.output_options
            ):
                self._regenerate_report = True
                return False

        return True

    @property
    def report_config(self) -> ReportConfiguration:
        """
        Returns the active report configuration based on the scope
        defined, if any, in the templates file.
        """
        return self._rpt_config

    @property
    def task_context(self) -> ReportTaskContext:
        """
        Returns an instance of the report task context that has been used
        to generate the corresponding report. This is for jobs that have
        successfully finished with the results in the datasets folder,
        otherwise it will return None.
        """
        return self._rpt_task_ctx

    @property
    def report_task_id(self) -> str:
        """
        Returns the task_id for generating the report which, in this case,
        corresponds to the job id..
        """
        return str(self._job.id)

    def view_report(self):
        # View report in the default pdf or image viewer.
        pass

    def open_designer(self):
        # Open template in the QGIS layout designer.
        pass

    @classmethod
    def tr(cls, source):
        return QCoreApplication.translate(
            'DatasetReportHandler',
            source
        )

    def generate_report(self):
        # Create report task context for report generation.
        self._rpt_task_ctx = ReportTaskContext(
            self._rpt_config,
            [self._job]
        )

        report_generator.process_report_task(
            self._rpt_task_ctx
        )


class MultiscopeJobReportModel(QStandardItemModel):
    """
    For displaying item scope - job pairing in the dialog for
    generating multiscope reports.
    """
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.setColumnCount(2)
        self.setHorizontalHeaderLabels([
            self.tr('Scope Name'),
            self.tr('Source Job')
        ])
        self._scope_job_mapping = dict()

    def load_scopes(self, scopes: typing.List[ItemScopeMapping]):
        # Load scope definitions to the collection
        self.clear_data()
        for sc in scopes:
            self.appendRow([QStandardItem(sc.name), QStandardItem()])

        # Sort by scope name
        self.sort(0)

    def clear_data(self):
        # Removes rows and resets scope collection
        self.removeRows(0, self.rowCount())
        self._scope_job_mapping = dict()

    @property
    def scope_job_mapping(self) -> typing.Dict[str, Job]:
        """
        Returns a mapping of scope name and corresponding job as specified
        by the user.
        """
        return self._scope_job_mapping

    def flags(self, index: QModelIndex):
        return Qt.ItemIsEnabled | Qt.ItemIsEditable


class JobSelectionItemDelegate(QStyledItemDelegate):
    """
    Delegate for selecting finished jobs matching a specific algorithm.
    """
    def __init__(self, scope_source_index: int, **kwargs):
        super().__init__(**kwargs)
        # Model index to fetch algorithm/scope name
        self._scope_source_idx = scope_source_index

    @property
    def scope_source_index(self) -> int:
        return self._scope_source_idx

    def createEditor(
            self,
            parent: QWidget,
            option: QStyleOptionViewItem,
            idx: QModelIndex
    ) -> QComboBox:
        job_combo = QComboBox(parent)

        # Add a list of completed jobs

        return job_combo

    def setEditorData(self, combo: QComboBox, idx: QModelIndex):
        job = idx.model().data(idx, Qt.EditRole)
        if job is None:
            return

        job_idx = combo.findText(job.visible_name)
        if job_idx != -1:
            combo.setCurrentIndex(job_idx)

    def setModelData(
            self,
            combo: QComboBox,
            model: QAbstractItemModel,
            idx: QModelIndex
    ):
        job = combo.itemData(combo.currentIndex())
        if job is not None:
            model.setData(idx, job, Qt.EditRole)

    def _on_job_changed(self, idx: int):
        # Commit job to the model
        job_combo = self.sender()
        self.commitData.emit(job_combo)

    def updateEditorGeometry(
            self,
            combo: QComboBox,
            option: QStyleOptionViewItem,
            idx: QModelIndex
    ):
        combo.setGeometry(option.rect)

