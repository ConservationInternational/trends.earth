"""
Code for calculating all three SDG 15.3.1 sub-indicators.
"""
# Copyright 2017 Conservation International

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import random
from builtins import str

import ee
from te_algorithms.gee.download import download
from te_algorithms.gee.util import teimage_v1_to_teimage_v2
from te_schemas import results
from te_schemas.schemas import BandInfo


def drought_vulnerability(params, EXECUTION_ID, logger):
    proj = ee.ImageCollection(params['population']['asset']
                              ).toBands().projection()

    out = download(
        'users/geflanddegradation/toolbox_datasets/jrc_global_drought_vulnerability_map',
        'Drought Vulnerability (JRC)', 'one time', None, None, logger
    )
    # Save as int16 to be compatible with other data
    out.image = out.image.multiply(10000).unmask(-32768).int16(
    ).rename('Drought_Vulnerability_JRC_2018').reproject(crs=proj)
    out.band_info[0].metadata.update({'scaling': .0001, 'year': 2018})
    out = teimage_v1_to_teimage_v2(out)

    logger.debug("Getting SPI images")

    lag = int(params['spi']['lag'])

    for year in range(params['year_initial'], params['year_final'] + 1):
        # Be inclusive of final year (+1) above
        add_to_map = bool(((year - params['year_initial']) % 4) == 0)
        out.add_image(
            **_get_spi(
                year,
                lag,
                params.get('spi'),
                proj,
                logger,
                add_to_map=add_to_map
            )
        )

    out.add_image(
        **_get_water(
            params['year_initial'], params.get('land_cover'), proj, logger
        )
    )

    logger.debug("Getting population images")

    for year in range(params['year_initial'], params['year_final'] + 1):
        # Be inclusive of final year (+1) above
        add_to_map = bool(((year - params['year_initial']) % 4) == 0)
        out.add_image(
            **_get_population(
                year, params.get('population'), logger, add_to_map
            )
        )

    return out.export(
        geojsons=params.get('geojsons'),
        task_name='drought_vulnerability',
        crs=params.get('crs'),
        logger=logger,
        execution_id=EXECUTION_ID,
        filetype=results.RasterFileType(
            params.get('filetype', results.RasterFileType.COG.value)
        )
    )


def _get_water(year, params, proj, logger, add_to_map=False):
    lc = ee.Image(params['asset'])
    lc = lc.select(f'y{year}')
    water = lc.eq(210)
    water = water.where(lc.eq(9999), -32768).updateMask(
        water.neq(-32768)
    ).unmask(-32768).int16().rename(f'Water_mask_{year}').reproject(crs=proj)

    return {
        'image':
        water,
        'bands': [
            BandInfo(
                "Water mask",
                metadata={
                    'year': year,
                    'source': params['source']
                },
                add_to_map=False
            )
        ],
        'datatype':
        results.DataType.INT16
    }


def _get_population(year, params, logger, add_to_map=False):
    '''Return WorldPop population data for a given year'''
    wp = ee.ImageCollection(params['asset']
                            ).filterDate(f'{year}-01-01', f'{year + 1}-01-01')
    wp = wp.select('male').toBands(
    ).rename(f'Population_{year}_male').addBands(
        wp.select('female').toBands().rename(f'Population_{year}_female')
    )

    return {
        'image':
        wp,
        'bands': [
            results.Band(
                "Population (number of people)",
                metadata={
                    'year': year,
                    'type': 'male',
                    'source': params['source'],
                },
                add_to_map=add_to_map
            ),
            results.Band(
                "Population (number of people)",
                metadata={
                    'year': year,
                    'type': 'female',
                    'source': params['source'],
                },
                add_to_map=add_to_map
            )
        ],
        'datatype':
        results.DataType.FLOAT32
    }


def _get_spi(year, lag, params, proj, logger, month=12, add_to_map=False):
    '''
    Return SPI image for a particular year and lag

    Note December image is used as default per SO3 guidance. This really only
    makes sense though if lag 12 is used
    '''
    spi_img = ee.ImageCollection(f"{params['asset']}").filterDate(
        f'{year}-{str(month).zfill(2)}-01'
    ).select(f'lag_{lag}').toBands().unmask(-32768).int16().reproject(
        crs=proj
    )

    return {
        'image':
        spi_img.unmask(-32768).int16(),
        'bands': [
            BandInfo(
                "Standardized Precipitation Index (SPI)",
                metadata={
                    'year': year,
                    'lag': lag,
                    'source': params['source'],
                },
                add_to_map=add_to_map
            )
        ],
        'datatype':
        results.DataType.INT16
    }


def run(params, logger):
    """."""
    logger.debug("Loading parameters.")

    # Check the ENV. Are we running this locally or in prod?

    if params.get('ENV') == 'dev':
        EXECUTION_ID = str(random.randint(1000000, 99999999))
    else:
        EXECUTION_ID = params.get('EXECUTION_ID', None)
    logger.debug(f"Execution ID is {EXECUTION_ID}")

    return drought_vulnerability(params, EXECUTION_ID, logger)
