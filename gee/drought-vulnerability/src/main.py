"""
Code for calculating all three SDG 15.3.1 sub-indicators.
"""
# Copyright 2017 Conservation International

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

from builtins import str
import random
import json

from concurrent.futures import (
    ThreadPoolExecutor,
    as_completed
)

import ee

from landdegradation.download import download
from landdegradation.util import TEImage

from te_schemas.schemas import CloudResultsSchema, BandInfo
from te_schemas.land_cover import LCTransitionDefinitionDeg, LCLegendNesting


def drought_vulnerability(params, EXECUTION_ID, logger):

    lag = int(params['spi']['lag'])
    proj = ee.Image(f"{params['spi']['asset']}{lag}").projection()

    logger.debug("Getting SPI and population data...")
    out = _get_spi(
        params['year_initial'],
        lag,
        params.get('spi'),
        logger,
        add_to_map=True
    )

    # Account for initial year already being in list (first +1), and be 
    # inclusive of final year (second +1)
    for year in range(params['year_initial'] + 1, params['year_final'] + 1):
        add_to_map = bool(((year - params['year_initial']) % 4) == 0)
        out.merge(
            _get_spi(
                year,
                lag,
                params.get('spi'),
                logger,
                add_to_map
            )
        )

    # Be inclusive of final year (+1)
    for year in range(params['year_initial'], params['year_final'] + 1):
        add_to_map = bool(((year - params['year_initial']) % 4) == 0)
        out.merge(
            _get_population(
                year,
                proj,
                params.get('population'),
                logger,
                add_to_map
            )
        )

    out.image = out.image.unmask(-32768).int16()

    return out.export(
        json.loads(params.get('geojsons')),
        'drought_vulnerability',
        params.get('crs'),
        logger,
        EXECUTION_ID,
        proj
    )


def _get_population(year, proj, params, logger, add_to_map=False):
    logger.debug("Returning population image")

    wp = ee.Image(params['asset']).select(f'p{year}')
    wp = wp.select(f'p{year}')
    # Convert to population density per sq km (ee.image.pixelArea gives area in 
    # sq meters, so need to convert). Then scale by 10 so max densities will 
    # fit in an int16
    wp = wp.divide(ee.Image.pixelArea()).multiply(1000*1000).divide(10).int16()
    wp = wp.reduceResolution(
        reducer=ee.Reducer.first(), maxPixels=1024
    ).reproject(proj)

    return TEImage(
        wp,
        [BandInfo(
            "Population (density, persons per sq km / 10)",
            metadata={
                'year': year,
                'source': params['source'],
                'scaling': .1
            },
            add_to_map=add_to_map
        )]
    )


def _get_spi(year, lag, params, logger, add_to_map=False):
    '''Return SPI image for a particular year and lag'''
    spi_img = ee.Image(f"{params['asset']}{lag}").select(f'spi_{year}_{lag}')

    return TEImage(
        spi_img.unmask(-32768).int16(),
        [BandInfo(
            "Standardized Precipitation Index (SPI)",
            metadata={
                'year': year,
                'lag': lag,
                'source': params['source'],
            },
            add_to_map=add_to_map
        )]
    )


def run(params, logger):
    """."""
    logger.debug("Loading parameters.")

    # Check the ENV. Are we running this locally or in prod?

    if params.get('ENV') == 'dev':
        EXECUTION_ID = str(random.randint(1000000, 99999999))
    else:
        EXECUTION_ID = params.get('EXECUTION_ID', None)

    out = drought_vulnerability(params, EXECUTION_ID, logger)

    return out
