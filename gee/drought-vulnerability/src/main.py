"""
Code for calculating drought vulnerability
"""

# Copyright 2017 Conservation International
import random
import re

import ee
from te_algorithms.gee.download import download
from te_schemas import results
from te_schemas.schemas import BandInfo


def _wp_filter_date(asset, fake_data, year, logger):
    """Filter WorldPop data by date, allowing for fallback to 2000 or 2020 if necessary"""
    wp = ee.ImageCollection(asset).filterDate(f"{year}-01-01", f"{year + 1}-01-01")
    if wp.getInfo()["bands"] == [] and fake_data:
        if year < 2000:
            logger.warning(
                f"Could not select year {year} from worldpop asset. Returning data from 2000."
            )
            wp = ee.ImageCollection(asset).filterDate("2000-01-01", "2001-01-01")
        elif year > 2020:
            logger.warning(
                f"Could not select year {year} from worldpop asset. Returning data from 2020."
            )
            wp = ee.ImageCollection(asset).filterDate("2020-01-01", "2021-01-01")
    return wp


def drought_vulnerability(params, EXECUTION_ID, logger):
    proj = ee.ImageCollection(params["population"]["asset"]).toBands().projection()

    out = download(
        "users/geflanddegradation/toolbox_datasets/jrc_global_drought_vulnerability_map",
        "Drought Vulnerability (JRC)",
        "one time",
        None,
        None,
        logger,
    )
    jrc_image = list(out.images.values())[0]
    # Save as int16 to be compatible with other data
    jrc_image.image = (
        jrc_image.image.multiply(10000)
        .unmask(-32768)
        .int16()
        .rename("Drought_Vulnerability_JRC_2018")
        .reproject(crs=proj)
    )
    jrc_image.bands[0].metadata.update({"scaling": 0.0001, "year": 2018})

    logger.debug("Getting SPI images")

    lag = int(params["spi"]["lag"])

    for year in range(params["year_initial"], params["year_final"] + 1):
        # Be inclusive of final year (+1) above
        add_to_map = bool(((year - params["year_initial"]) % 4) == 0)
        out.add_image(
            **_get_spi(
                year, lag, params.get("spi"), proj, logger, add_to_map=add_to_map
            )
        )

    out.add_image(
        **_get_water(params["year_initial"], params.get("land_cover"), proj, logger)
    )

    logger.debug("Getting population images")

    for year in range(params["year_initial"], params["year_final"] + 1):
        # Be inclusive of final year (+1) above
        add_to_map = bool(((year - params["year_initial"]) % 4) == 0)
        out.add_image(
            **_get_population(year, params.get("population"), logger, add_to_map)
        )

    return out.export(
        geojsons=params.get("geojsons"),
        task_name="drought_vulnerability",
        crs=params.get("crs"),
        logger=logger,
        execution_id=EXECUTION_ID,
        filetype=results.RasterFileType(
            params.get("filetype", results.RasterFileType.COG.value)
        ),
    )


def _get_water(year, params, proj, logger, add_to_map=False):
    lc = ee.Image(params["asset"])
    lc = lc.select(f"y{year}")
    water = lc.eq(210)
    water = (
        water.where(lc.eq(9999), -32768)
        .updateMask(water.neq(-32768))
        .unmask(-32768)
        .int16()
        .rename(f"Water_mask_{year}")
        .reproject(crs=proj)
    )

    return {
        "image": water,
        "bands": [
            BandInfo(
                "Water mask",
                metadata={"year": year, "source": params["source"]},
                add_to_map=False,
            )
        ],
        "datatype": results.DataType.INT16,
    }


def _get_population(year, params, logger, add_to_map=False):
    """Return WorldPop population data for a given year"""
    wp = _wp_filter_date(params["asset"], params.get("fake_data", False), year, logger)
    wp = (
        wp.select("male")
        .toBands()
        .rename(f"Population_{year}_male")
        .addBands(wp.select("female").toBands().rename(f"Population_{year}_female"))
    )

    return {
        "image": wp,
        "bands": [
            results.Band(
                "Population (number of people)",
                metadata={
                    "year": year,
                    "type": "male",
                    "source": params["source"],
                },
                add_to_map=add_to_map,
            ),
            results.Band(
                "Population (number of people)",
                metadata={
                    "year": year,
                    "type": "female",
                    "source": params["source"],
                },
                add_to_map=add_to_map,
            ),
        ],
        "datatype": results.DataType.FLOAT32,
    }


def _get_spi(year, lag, params, proj, logger, month=12, add_to_map=False):
    """
    Return SPI image for a particular year and lag

    Note December image is used as default per SO3 guidance. This really only
    makes sense though if lag 12 is used
    """

    collection = ee.ImageCollection(f"{params['asset']}")
    if re.search("ukceh", params["asset"]):
        # UKCEH data is labeled with image names containing year
        collection = collection.filter(
            ee.Filter.equals("system:index", f"spi{lag}_dec_{year}")
        )
    else:
        # CHIRPS and GPCC data are filtered using the date field
        collection = collection.filterDate(f"{year}-{str(month).zfill(2)}-01")
    image = (
        collection.select(f"lag_{lag}")
        .toBands()
        .unmask(-32768)
        .int16()
        .reproject(crs=proj)
    )
    if image.bandNames().length() == 0:
        logger.warning(
            f"Failed to load SPI for year {year} and lag {lag}. Returning nodata."
        )
        image = ee.Image.constant(-32768).int16().reproject(crs=proj)

    return {
        "image": image,
        "bands": [
            BandInfo(
                "Standardized Precipitation Index (SPI)",
                metadata={
                    "year": year,
                    "lag": lag,
                    "source": params["source"],
                },
                add_to_map=add_to_map,
            )
        ],
        "datatype": results.DataType.INT16,
    }


def run(params, logger):
    """."""
    logger.debug("Loading parameters.")

    # Check the ENV. Are we running this locally or in prod?

    if params.get("ENV") == "dev":
        EXECUTION_ID = str(random.randint(1000000, 99999999))
    else:
        EXECUTION_ID = params.get("EXECUTION_ID", None)
    logger.debug(f"Execution ID is {EXECUTION_ID}")

    return drought_vulnerability(params, EXECUTION_ID, logger)
